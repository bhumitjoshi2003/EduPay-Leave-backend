package com.indraacademy.ias_management.service;

import com.indraacademy.ias_management.dto.UserNotificationDTO;
import com.indraacademy.ias_management.entity.Notification;
import com.indraacademy.ias_management.entity.UserNotification;
import com.indraacademy.ias_management.repository.NotificationRepository;
import com.indraacademy.ias_management.repository.UserNotificationRepository;
import com.indraacademy.ias_management.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.time.Period;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class NotificationService {

    @Autowired private AuthService authService;
    @Autowired private NotificationRepository notificationRepository;
    @Autowired private UserNotificationRepository userNotificationRepository;
    @Autowired private UserRepository userRepository;

    @Transactional
    public Notification createBroadNotification(Notification notification, String authorizationHeader) {
        notification.setCreatedBy(authService.getUserIdFromToken(authorizationHeader));
        notification.setCreatedAt(LocalDateTime.now());
        return notificationRepository.save(notification);
    }

    @Transactional
    public UserNotification createAutoGeneratedIndividualNotification(
            String title, String message, String type, String userId,
            String relatedEntityType, Long relatedEntityId) {

        Notification notification = new Notification();
        notification.setTitle(title);
        notification.setMessage(message);
        notification.setType(type);
        notification.setAudience(userId);
        notification.setCreatedAt(LocalDateTime.now());
        Notification savedNotification = notificationRepository.save(notification);

        UserNotification userNotification = new UserNotification();
        userNotification.setUserId(userId);
        userNotification.setNotification(savedNotification);
        userNotification.setIsRead(false);
        userNotification.setCreatedAt(LocalDateTime.now());
        return userNotificationRepository.save(userNotification);
    }


    @Transactional
    public List<UserNotificationDTO> getNotificationsForUser(String userId, String userRole) {
        // 1. Fetch existing user-specific notifications (these might be direct or previously created from broad notifications)
        // This is important to retain the 'isRead' status and individual notification IDs for the user.
        List<UserNotification> userNotifications = new ArrayList<>(userNotificationRepository.findByUserIdOrderByCreatedAtDesc(userId));

        // 2. Fetch broad/general notifications based on user's role and their specific ID if applicable
        List<Notification> broadNotifications = notificationRepository.findAll().stream()
                .filter(notification -> {
                    String audience = notification.getAudience();
                    // Removed: if (audience == null) return false; // As per your clarification, audience is never null

                    // For students, include "ALL", "STUDENTS", OR their specific userId
                    if ("STUDENT".equals(userRole)) {
                        return "ALL".equals(audience) ||
                                "STUDENTS".equals(audience) ||
                                userId.equals(audience); // This correctly picks up S101 for student S101
                    }
                    // For teachers, include "ALL", "TEACHERS", OR their specific userId (assuming T101 for teacher T101)
                    else if ("TEACHER".equals(userRole)) {
                        return "ALL".equals(audience) ||
                                "TEACHERS".equals(audience) ||
                                userId.equals(audience); // Added for teachers too, assuming similar personalized notifications
                    }
                    // For any other roles, or if a notification has an audience not matching role or user ID
                    return false;
                })
                .toList();

        // 3. Create UserNotification entries for relevant broad notifications if they don't exist for this user
        for (Notification broadNotif : broadNotifications) {
            if (!userNotificationRepository.existsByUserIdAndNotificationId(userId, broadNotif.getId())) {
                UserNotification newUserNotif = new UserNotification();
                newUserNotif.setUserId(userId);
                newUserNotif.setNotification(broadNotif);
                newUserNotif.setIsRead(false);
                newUserNotif.setCreatedAt(broadNotif.getCreatedAt()); // Use broad notification's creation time
                userNotifications.add(newUserNotif);
            }
        }

        // 4. Sort the combined list by creation date in descending order
        userNotifications.sort((n1, n2) -> n2.getCreatedAt().compareTo(n1.getCreatedAt()));

        // 5. Convert UserNotification entities to DTOs for the API response
        return userNotifications.stream()
                .map(userNotif -> {
                    UserNotificationDTO dto = new UserNotificationDTO();
                    dto.setId(userNotif.getId());
                    dto.setUserId(userNotif.getUserId());
                    dto.setCreatedAt(userNotif.getCreatedAt());

                    if (userNotif.getNotification() != null) {
                        dto.setTitle(userNotif.getNotification().getTitle());
                        dto.setMessage(userNotif.getNotification().getMessage());
                        dto.setType(userNotif.getNotification().getType());
                        // Add other fields from Notification here if needed in DTO
                    }
                    return dto;
                })
                .collect(Collectors.toList());
    }

    @Transactional
    public long getUnreadNotificationCount(String userId, String userRole) {
        return userNotificationRepository.countByUserIdAndIsReadFalse(userId);
    }


    @Transactional
    public void markAllNotificationsAsRead(String userId) {
        List<UserNotification> unreadPersonalizedNotifications = userNotificationRepository.findByUserIdAndIsReadFalseOrderByCreatedAtDesc(userId)
                .stream()
                .filter(un -> un.getNotification().getAudience().equals(userId))
                .toList();

        for (UserNotification notification : unreadPersonalizedNotifications) {
            notification.setIsRead(true);
            userNotificationRepository.save(notification);
        }
    }

    // --- Admin-specific methods (CRUD for broad notifications) ---

    public Optional<Notification> getNotificationById(Long id) {
        return notificationRepository.findById(id);
    }

    @Transactional
    public Notification updateNotification(Long id, Notification updatedNotification, String authorizationHeader) {
        Optional<Notification> existingNotification = notificationRepository.findById(id);
        if (existingNotification.isPresent()) {
            Notification notification = existingNotification.get();
            notification.setTitle(updatedNotification.getTitle());
            notification.setMessage(updatedNotification.getMessage());
            notification.setType(updatedNotification.getType());
            notification.setAudience(updatedNotification.getAudience());
            notification.setCreatedBy(authService.getUserIdFromToken(authorizationHeader));
            return notificationRepository.save(notification);
        }
        return null;
    }

    @Transactional
    public void deleteNotification(Long id) {
        notificationRepository.deleteById(id);
    }

    public List<Notification> getAllBroadNotifications() {
        return notificationRepository.findAll().stream()
                .filter(n -> n.getAudience() != null)
                .collect(Collectors.toList());
    }

    public List<Notification> getAllNotifications() {
        return notificationRepository.findByCreatedByIsNotNull();
    }

    @Scheduled(cron = "0 0 2 * * ?")
    @Transactional
    public void cleanupOldNotifications() {
        LocalDateTime twoMonthsAgo = LocalDateTime.now().minus(Period.ofMonths(1));
        List<Notification> oldNotifications = notificationRepository.findByCreatedAtBefore(twoMonthsAgo);

        for (Notification notification : oldNotifications) {
            deleteNotification(notification.getId());
        }
    }
}