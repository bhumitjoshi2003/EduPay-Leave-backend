package com.indraacademy.ias_management.service;

import com.indraacademy.ias_management.dto.UserNotificationDTO;
import com.indraacademy.ias_management.entity.Notification;
import com.indraacademy.ias_management.entity.UserNotification;
import com.indraacademy.ias_management.repository.NotificationRepository;
import com.indraacademy.ias_management.repository.UserNotificationRepository;
import com.indraacademy.ias_management.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.LocalDateTime;
import java.time.Period;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class NotificationService {

    private static final Logger log = LoggerFactory.getLogger(NotificationService.class);

    @Autowired private AuthService authService;
    @Autowired private NotificationRepository notificationRepository;
    @Autowired private UserNotificationRepository userNotificationRepository;
    @Autowired private UserRepository userRepository; // Not used in original, but kept

    @Transactional
    public Notification createBroadNotification(Notification notification, String authorizationHeader) {
        if (notification == null || notification.getTitle() == null || notification.getMessage() == null) {
            log.warn("Attempted to create broad notification with missing required fields.");
            throw new IllegalArgumentException("Notification object and its title/message must not be null.");
        }
        log.info("Creating broad notification: {} for audience: {}", notification.getTitle(), notification.getAudience());

        try {
            String createdBy = authService.getUserIdFromToken(authorizationHeader);
            if (createdBy == null) {
                log.warn("Could not extract user ID from token for broad notification creation.");
            }
            notification.setCreatedBy(createdBy);
            notification.setCreatedAt(LocalDateTime.now());

            Notification savedNotification = notificationRepository.save(notification);
            log.info("Broad notification created successfully with ID: {}", savedNotification.getId());
            return savedNotification;
        } catch (DataAccessException e) {
            log.error("Data access error during broad notification creation: {}", notification.getTitle(), e);
            throw new RuntimeException("Could not create broad notification due to data access issue", e);
        }
    }

    @Transactional
    public UserNotification createAutoGeneratedIndividualNotification(
            String title, String message, String type, String userId,
            String relatedEntityType, String relatedEntityId) {

        if (title == null || message == null || userId == null) {
            log.warn("Attempted to create individual notification with missing required fields for user: {}", userId);
            throw new IllegalArgumentException("Title, message, and user ID are required for individual notification.");
        }
        log.info("Creating individual notification for user: {} with title: {}", userId, title);

        try {
            // 1. Create and save the Notification entity
            Notification notification = new Notification();
            notification.setTitle(title);
            notification.setMessage(message);
            notification.setType(type);
            notification.setAudience(userId);
            notification.setCreatedAt(LocalDateTime.now());
            Notification savedNotification = notificationRepository.save(notification);

            // 2. Create and save the UserNotification entity
            UserNotification userNotification = new UserNotification();
            userNotification.setUserId(userId);
            userNotification.setNotification(savedNotification);
            userNotification.setIsRead(false);
            userNotification.setCreatedAt(LocalDateTime.now());

            UserNotification savedUserNotification = userNotificationRepository.save(userNotification);
            log.info("Individual notification created successfully for user: {}. Notification ID: {}", userId, savedNotification.getId());
            return savedUserNotification;
        } catch (DataAccessException e) {
            log.error("Data access error during individual notification creation for user: {}", userId, e);
            throw new RuntimeException("Could not create individual notification due to data access issue", e);
        }
    }


    @Transactional
    public List<UserNotificationDTO> getNotificationsForUser(String userId, String userRole) {
        if (userId == null || userRole == null) {
            log.warn("Attempted to fetch notifications with null user ID or role.");
            return Collections.emptyList();
        }
        log.info("Fetching notifications for user: {} with role: {}", userId, userRole);

        List<UserNotification> userNotifications;
        List<Notification> broadNotifications;

        try {
            // 1. Fetch existing user-specific notifications
            userNotifications = new ArrayList<>(userNotificationRepository.findByUserIdOrderByCreatedAtDesc(userId));

            // 2. Fetch broad/general notifications based on user's role
            broadNotifications = notificationRepository.findAll().stream()
                    .filter(notification -> {
                        String audience = notification.getAudience();
                        if (audience == null) return false;

                        if ("STUDENT".equalsIgnoreCase(userRole)) {
                            return "ALL".equalsIgnoreCase(audience) ||
                                    "STUDENTS".equalsIgnoreCase(audience) ||
                                    userId.equals(audience);
                        } else if ("TEACHER".equalsIgnoreCase(userRole)) {
                            return "ALL".equalsIgnoreCase(audience) ||
                                    "TEACHERS".equalsIgnoreCase(audience) ||
                                    userId.equals(audience);
                        }
                        return false;
                    })
                    .toList();
        } catch (DataAccessException e) {
            log.error("Data access error during notification fetch for user: {}", userId, e);
            throw new RuntimeException("Could not retrieve notifications due to data access issue", e);
        }

        // 3. Create UserNotification entries for relevant broad notifications if they don't exist
        int newNotificationsCount = 0;
        for (Notification broadNotif : broadNotifications) {
            try {
                if (!userNotificationRepository.existsByUserIdAndNotificationId(userId, broadNotif.getId())) {
                    UserNotification newUserNotif = new UserNotification();
                    newUserNotif.setUserId(userId);
                    newUserNotif.setNotification(broadNotif);
                    newUserNotif.setIsRead(false);
                    newUserNotif.setCreatedAt(broadNotif.getCreatedAt());
                    userNotifications.add(userNotificationRepository.save(newUserNotif));
                    newNotificationsCount++;
                }
            } catch (DataAccessException e) {
                log.error("Data access error creating UserNotification for broad notification ID: {} for user: {}", broadNotif.getId(), userId, e);
                // Continue loop to process remaining notifications
            }
        }
        log.debug("Created {} new UserNotification entries for user {}.", newNotificationsCount, userId);

        // 4. Sort the combined list
        userNotifications.sort((n1, n2) -> n2.getCreatedAt().compareTo(n1.getCreatedAt()));

        // 5. Convert to DTOs
        return userNotifications.stream()
                .map(userNotif -> {
                    UserNotificationDTO dto = new UserNotificationDTO();
                    dto.setId(userNotif.getId());
                    dto.setUserId(userNotif.getUserId());
                    dto.setCreatedAt(userNotif.getCreatedAt());

                    Notification notification = userNotif.getNotification();
                    if (notification != null) {
                        dto.setTitle(notification.getTitle());
                        dto.setMessage(notification.getMessage());
                        dto.setType(notification.getType());
                    }
                    return dto;
                })
                .collect(Collectors.toList());
    }

    @Transactional
    public long getUnreadNotificationCount(String userId, String userRole) {
        if (userId == null) {
            log.warn("Attempted to get unread count with null user ID.");
            return 0;
        }
        log.info("Counting unread notifications for user: {}", userId);
        try {
            return userNotificationRepository.countByUserIdAndIsReadFalse(userId);
        } catch (DataAccessException e) {
            log.error("Data access error counting unread notifications for user: {}", userId, e);
            throw new RuntimeException("Could not retrieve unread notification count due to data access issue", e);
        }
    }


    @Transactional
    public void markAllNotificationsAsRead(String userId) {
        if (userId == null) {
            log.warn("Attempted to mark notifications as read with null user ID.");
            return;
        }
        log.info("Marking all personalized unread notifications as read for user: {}", userId);

        try {
            List<UserNotification> notificationsToMark = userNotificationRepository.findByUserIdAndIsReadFalseOrderByCreatedAtDesc(userId)
                    .stream()
                    // Filter to only mark personalized/direct notifications as read, NOT broad ones.
                    // This is based on the assumption that the original intent was only to mark specific ones.
                    .filter(un -> un.getNotification() != null && userId.equals(un.getNotification().getAudience()))
                    .toList();

            for (UserNotification notification : notificationsToMark) {
                notification.setIsRead(true);
                userNotificationRepository.save(notification);
            }
            log.info("Marked {} personalized notifications as read for user: {}", notificationsToMark.size(), userId);
        } catch (DataAccessException e) {
            log.error("Data access error marking notifications as read for user: {}", userId, e);
            throw new RuntimeException("Could not mark notifications as read due to data access issue", e);
        }
    }

    // --- Admin-specific methods (CRUD for broad notifications) ---

    public Optional<Notification> getNotificationById(Long id) {
        if (id == null) {
            log.warn("Attempted to get notification with null ID.");
            return Optional.empty();
        }
        log.info("Fetching notification by ID: {}", id);
        try {
            return notificationRepository.findById(id);
        } catch (DataAccessException e) {
            log.error("Data access error fetching notification ID: {}", id, e);
            throw new RuntimeException("Could not retrieve notification due to data access issue", e);
        }
    }

    @Transactional
    public Notification updateNotification(Long id, Notification updatedNotification, String authorizationHeader) {
        if (id == null || updatedNotification == null) {
            log.error("Cannot update notification: ID or updated object is null.");
            throw new IllegalArgumentException("Notification ID and details must not be null.");
        }
        log.info("Attempting to update notification with ID: {}", id);

        try {
            Optional<Notification> existingNotification = notificationRepository.findById(id);
            if (existingNotification.isPresent()) {
                Notification notification = existingNotification.get();
                notification.setTitle(updatedNotification.getTitle());
                notification.setMessage(updatedNotification.getMessage());
                notification.setType(updatedNotification.getType());
                notification.setAudience(updatedNotification.getAudience());

                String createdBy = authService.getUserIdFromToken(authorizationHeader);
                if (createdBy == null) {
                    log.warn("Could not extract user ID from token during notification update.");
                }
                // Assuming 'createdBy' is used here as 'updatedBy'
                notification.setCreatedBy(createdBy);

                Notification savedNotification = notificationRepository.save(notification);
                log.info("Notification updated successfully with ID: {}", id);
                return savedNotification;
            }
            log.warn("Notification not found for update with ID: {}", id);
            return null;
        } catch (DataAccessException e) {
            log.error("Data access error during notification update for ID: {}", id, e);
            throw new RuntimeException("Could not update notification due to data access issue", e);
        }
    }

    @Transactional
    public void deleteNotification(Long id) {
        if (id == null) {
            log.warn("Attempted to delete notification with null ID.");
            return;
        }
        log.info("Attempting to delete notification with ID: {}", id);
        try {
            notificationRepository.deleteById(id);
            log.info("Notification deleted successfully with ID: {}", id);
        } catch (DataAccessException e) {
            log.error("Data access error deleting notification ID: {}", id, e);
            throw new RuntimeException("Could not delete notification due to data access issue", e);
        }
    }

    public List<Notification> getAllBroadNotifications() {
        log.info("Fetching all broad notifications.");
        try {
            return notificationRepository.findAll().stream()
                    .filter(n -> n.getAudience() != null)
                    .collect(Collectors.toList());
        } catch (DataAccessException e) {
            log.error("Data access error fetching all broad notifications.", e);
            throw new RuntimeException("Could not retrieve broad notifications due to data access issue", e);
        }
    }

    public List<Notification> getAllNotifications() {
        log.info("Fetching all notifications with a creator.");
        try {
            return notificationRepository.findByCreatedByIsNotNull();
        } catch (DataAccessException e) {
            log.error("Data access error fetching all notifications.", e);
            throw new RuntimeException("Could not retrieve all notifications due to data access issue", e);
        }
    }

    @Scheduled(cron = "0 0 2 * * ?")
    @Transactional
    public void cleanupOldNotifications() {
        log.info("Starting scheduled cleanup of old notifications.");
        try {
            LocalDateTime oneMonthAgo = LocalDateTime.now().minus(Period.ofMonths(1));
            List<Notification> oldNotifications = notificationRepository.findByCreatedAtBefore(oneMonthAgo);

            for (Notification notification : oldNotifications) {
                // Ensure proper cascade/manual deletion of UserNotification first if necessary,
                // though JPA cascade annotations should handle it.
                notificationRepository.delete(notification);
            }
            log.info("Cleaned up {} old notifications created before {}", oldNotifications.size(), oneMonthAgo);
        } catch (DataAccessException e) {
            log.error("Data access error during scheduled notification cleanup.", e);
        }
    }
}